---
layout: post
title: Bitwise Operation
excerpt: ""
categories: [LeetCode]
tag: [JavaScript, Bitwise operation]
comments: true
---

## 260 Single Number III

[Description](https://leetcode.com/problems/single-number-iii/description/)

### 位运算*

```js
var singleNumber = function(nums) {

//Pass 1
  var diff = nums.reduce((diff, num) => diff ^ num, 0);  //Get the XOR of the two numbers we need to find
  diff =  -diff & diff;  // Get its last set bit

//Pass2
  ret = nums.reduce((ret, num) => (num & diff ===0 ) ? 
	[ret[0] ^ num, ret[1]] //the bit is set in num
	: [ret[0], ret[1] ^ num], //the bit is not set in num
	[0, 0]);  //(initial value)
  return ret;
};
```

#### Pass 1

> 对所有数字进行XOR运算，得到只出现一次的两个目标数字的XOR. 

为了对所有数字进行XOR，这里采用了.reduce()方法. 异或操作遵循交换律且a^a===0，所以diff的结果是唯一两个出现一次的数的异或.

diff = -diff & diff（一个数和它负数的AND运算）结果中总有一位为1（形似 0..010..0）

#### Pass 2

> 所有数字中必定有一部分在diff为1的位置上也为1，其余数在该位上是0（num & diff ===0）.两组数字分别包含了我们要找的两个数（因为它们的XOR在该位上是1）.

两组数字内部再进行XOR运算，出现两次的那些通过a^a=0互相抵消，所以两组XOR的结果就是我们要找的数字.

| Time approximation | Time complexity | Space complexity |
|:--------|:-------|:--------|
| 64ms | O(N)| O(1) |

### 排序后遍历

```js
var singleNumber = function(nums) {
    var ones=[];
    nums.sort(function(a,b){
        return a-b;
    })
    while(nums.length>0){
        let num = nums.shift();
        ones.push(num);
        if(num===nums[0]){
            ones.pop();
            nums.shift();
        }
    }
    return ones;
};
```

| Time approximation | Time complexity | Space complexity |
|:--------|:-------|:--------|
| 88ms | worse than O(N) | O(1) |

排序的好处是只需要使用O(1)的额外空间，因为排序后的nums中相同的数字一定出现在数组的下一位。但是sort()原生方法的时间复杂度可能不低。

#### Array.prototype.sort() performance

[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) The time and space complexity of the sort cannot be guaranteed as it is implementation dependent. ECMAScript没有规定sort()的算法，所以取决于浏览器的实现.

[StackOverflow](https://stackoverflow.com/questions/234683/javascript-array-sort-implementation) （据说是）WebKit的实现：

* *Numeric arrays (or arrays of primitive type)* quicksort (usually introsort).

* *Contiguous arrays of non-numeric type* are stringified and sorted using mergesort, if available (to obtain a stable sorting) or qsort if no merge sort is available.

* *Other types (non-contiguous arrays and presumably for associative arrays)* either selection sort (which they call "min" sort) or, in some cases, it sorts via an AVL tree.

### 使用map

```js
var singleNumber = function(nums) {
    var ones=[];
    var map={};
    for(var i=0;i<nums.length;i++){
        if(map[nums[i]]){
            delete map[nums[i]];
        }else{
            map[nums[i]]=1;
        }
    }
    for(var key in map){
        ones.push(parseInt(key));
    }
    return ones;
};

```

| Time approximation | Time complexity | Space complexity |
|:--------|:-------|:--------|
| 72ms | O(N)| O(N) |

JS中map()是使用hash table实现的，所以可以达到O(N)的时间复杂度；缺点是空间复杂度达到O(N)